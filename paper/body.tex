\section{Introduction}\label{section:Introduction}
Many permission models today are broken for the type of applications being used today. We've gone from systems that run only trusted programs to PCs, mobile devices, and other systems where users want to run untrusted or semi-trusted code. The permission models have not kept pace with the change in computing landscape. Existing permission models either protect only from other users, ignoring the threat of untrusted code, provide shallow and overly broad protections, or use unwieldy and complicated configuration mechanics. We present a new permission model based on the idea that you have data to protect, and you want to protect it against snooping applications. We design and implement our language inside of Racket\cite{racket}. We evaluate our base implementation by building up two common command line programs, ls and cat. Using these programs we evaluate our permission model to prevent access to certain resources.

\section{Related Work}\label{section:relatedwork}
%SELinux is used both on Android and Linux to constrain applications from accessing or using Kernel nodes, directories, files or sockets. 
%The BSD operating systems have two mechanisms for mandatory access control. 
%FreeBSD has Capsicum, a capability based system which essentially sandboxes applicaitons. 
%OpenBSD has a new mechanism \textit{tame()} which is a subsystem  to restrict programs into a "reduced feature operating model".
%All these mechanisms have one thing in common, they're baked into the operating system and not interchangeable. We propose limiting access at the language and language runtime level, instead at the operating system level. 

\section{Adversary Model}\label{section:adversary-model}
Our adversary model is based around the creators of the software that you install on your device and what information can be gathered/changed without your knowledge. We classified our adversary's into two main categories, Legitimate Advertising Businesses and Malware Distributors.

Legitimate Businesses typically provide the software free of charge but gather personal information available on your device to be used for advertising purposes.  While they are legal entities they are often viewed as malicious, or at least overstepping their bounds on data collection, and tend to scoop up much more personal information than people realize or want to allow. Typical examples of these entities are Google and Facebook.  

Malware Distributors also provide software that appears to have a legitimate purpose. The legitimate purpose is used to mask the true malicious nature of the software. The goal of these adversaries is typically unlawful activities that can cause the user harm. This can be destruction of data, ransomware, identity theft and botnet creation. Typical examples of these type of adversaries are Crypto-Locker, Spam Distributors and people on Darkode.

These code written by these adversaries is knowingly run by users, although they do not know what the software does.  Adversaries generally have access to file system and network resources on the user's device, and are only limited by access and permission systems used by the operating system or runtime environment.

\subsection{Permission-Model}\label{section:Permssion-model}

\subsection{Racket-hash-lang}\label{section:racket}

\section{Architecture}\label{section:arch}

\section{Results}\label{section:results}

\section{Future Work}\label{section:futurework}
We believe that our work is a step in the right direction and a good iteration on top of some of the previous permission models being shipped today. For permission models to be successful they need to continue to develop and allow users the ability to make generic permissions on top of fine grained permissions. Without the ability to combine and create higher level permissions, the permission model could soon become obsolete by an evolving computing landscape.\\
\indent
Runtime checking of permissions, as well as the ability to add or revoke permissions at runtime will are an extremely important feature that we built. We argue that this ability to modify permissions at runtime is one of the most important features for a permission system. For example, if a user is near their data cap on their phone, they may wish to revoke permission to use the internet from applications. We believe that the benefits of this feature of a permission model out weighs the burden put on developers who are then required to gracefully handle not having specific permissions at runtime. Android 6.0 has taken this approach, you can now, as a user, revoke certain permissiosn at runtime, see Figure 1 for an example.\\
\indent
Lastly, permission models need to let users add their own permissions. While android gives you the ability to revoke permissions at runtime, it doesn't let the user make their own permissions. Google creates the permissions and sets what those permissions can and cannot do. This isn't in the users best interest for two reasons: Google is an advertising company so they want access to some data. Second, different people have different levels of privacy they want to keep on their phones. An example of defining custom permissions could be an app wants access to some text messages for a legitimate reason. A user could generate a permission that says, this app has access to the text messages from John from the past 3 hours.\\



