\section{Introduction}\label{section:Introduction}
Many permission models today are broken for the type of applications being used today. We've gone from systems that run only trusted programs to PCs, mobile devices, and other systems where users want to run untrusted or semi-trusted code. The permission models have not kept pace with the change in computing landscape. Existing permission models either protect only from other users, ignoring the threat of untrusted code, provide shallow and overly broad protections, or use unwieldy and complicated configuration mechanics. We present a new permission model based on the idea that you have data to protect, and you want to protect it against snooping applications. We design and implement our language inside of Racket\cite{racket}. We evaluate our base implementation by building up two common command line programs, ls and cat. Using these programs we evaluate our permission model to prevent access to certain resources.

\section{Related Work}\label{section:relatedwork}
Related work includes the Unix permission model, mandatory access control systems, and the Android permission model.

Unix permissions provide a simple and useful model for protecting against other users on a system, but they do not protect a user against malicious applications.

Mandatory access systems give greater protections, and are generally extensions of the Unix model that work with it.  These include SELinux, AppArmor, Tomoyo Linux, Capsicum, and Tame.
SELinux is used both on Android and Linux to constrain applications from accessing or using Kernel nodes, directories, files or sockets. 
AppArmor and Tomoyo are additional optional systems for Linux which restrict applications based on configurable application contexts.
FreeBSD has Capsicum, a capability based system which essentially sandboxes applications. 
OpenBSD has a new mechanism \textit{tame()} which is a subsystem  to restrict programs into a "reduced feature operating model".
All of these mandatory access systems have complex models that are difficult for users to understand.  
They must be configured with complicated text files that can be edited only by root.  
This makes it impossible for normal users to control them, or for non-root users to set their personal security policy.

Android re-purposes the classic Unix permission model by treating each application as a different user, and has a variety of different high-level permissions that applications can request.
The Android security model is the most commonly used model on consumer devices, and some consider it to be the state of the art.
However, the Android permission model has many flaws.
Permissions must be granted at install-time, which most users don't pay attention to.
Many permissions are overly broad, such as full sd-card access.
Many permissions have confusing names and descriptions, and it is difficult to find out what they really do.
All permissions must be granted, so users can not allow partial access to applications to get the functionality they desire while blocking functionality they want to disallow.
Finally, all permissions are designed by Google, whom many view as an adversary, with no possibility for extension by other parties that the user trusts.
Android version 6 was released while we were working on this project, which allows run-time permission configuration, fixing some of the issues, but the others still exist.


\section{Adversary Model}\label{section:adversary-model}
Our adversary model is based around the creators of the software that you install on your device and what information can be gathered/changed without your knowledge. We classified our adversary's into two main categories, Legitimate Advertising Businesses and Malware Distributors.

Legitimate Businesses typically provide the software free of charge but gather personal information available on your device to be used for advertising purposes.  While they are legal entities they are often viewed as malicious, or at least overstepping their bounds on data collection, and tend to scoop up much more personal information than people realize or want to allow. Typical examples of these entities are Google and Facebook.  

Malware Distributors also provide software that appears to have a legitimate purpose. The legitimate purpose is used to mask the true malicious nature of the software. The goal of these adversaries is typically unlawful activities that can cause the user harm. This can be destruction of data, ransomware, identity theft and botnet creation. Typical examples of these type of adversaries are Crypto-Locker, Spam Distributors and people on Darkode.

These code written by these adversaries is knowingly run by users, although they do not know what the software does.  Adversaries generally have access to file system and network resources on the user's device, and are only limited by access and permission systems used by the operating system or runtime environment.

\section{Methodology}\label{section:methodology}

\section{Implementation}\label{section:implementation}

\section{Conclusion}\label{section:conclusion}

\section{Future Work}\label{section:futurework}
We believe that our work is a step in the right direction and a good iteration on top of some of the previous permission models being shipped today. For permission models to be successful they need to continue to develop and allow users the ability to make generic permissions on top of fine grained permissions. Without the ability to combine and create higher level permissions, the permission model could soon become obsolete by an evolving computing landscape.\\
\indent
Runtime checking of permissions, as well as the ability to add or revoke permissions at runtime will are an extremely important feature that we built. We argue that this ability to modify permissions at runtime is one of the most important features for a permission system. For example, if a user is near their data cap on their phone, they may wish to revoke permission to use the internet from applications. We believe that the benefits of this feature of a permission model out weighs the burden put on developers who are then required to gracefully handle not having specific permissions at runtime. Android 6.0 has taken this approach, you can now, as a user, revoke certain permissiosn at runtime, see Figure 1 for an example.\\
\indent
Lastly, permission models need to let users add their own permissions. While android gives you the ability to revoke permissions at runtime, it doesn't let the user make their own permissions. Google creates the permissions and sets what those permissions can and cannot do. This isn't in the users best interest for two reasons: Google is an advertising company so they want access to some data. Second, different people have different levels of privacy they want to keep on their phones. An example of defining custom permissions could be an app wants access to some text messages for a legitimate reason. A user could generate a permission that says, this app has access to the text messages from John from the past 3 hours.\\



